---
title: "Exploring phylogeny and trait correlation"
date: '`r format(Sys.Date(), "%B %d %Y")`'
author: "Will Harvey"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exploring tree structure}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
```

```{r, message = FALSE}
# load the package into R
library(toolkitSeqTree)

# load other useful packages
library(ape)
library(ggtree)
library(ggplot2)
library(RColorBrewer)
```

## Simulate tree and discrete traits

A tree can be read in from an external file but here it is generated by the function `rtree()` from the `ape` package. The function "fortify" from the *ggtree* package, `ggtree::fortify()`, is used to generate a data frame describing the tree. Each row in the tree represents a node/branch in the phylogeny. The important columns required by functions here are `node`, `parent`, `isTip`, and `branch.length`.

```{r}
# generate a random tree with 100 tips
tree <- ape::rtree(n = 100)
ggtree(tree)

tree_dat <- fortify(tree)
head(tree_dat)
```

Generate two binary discrete traits in which to explore phylogenetic signal. The first, `trait_A` will be randomly distributed across the tree. The second trait, `trait_B`, will be generated using the position of the tip in the y axis which should introduce a phylogenetic signal given related tips are more likely to be near in the y dimension.

```{r}
tree_dat$trait_A <- NA
tree_dat$trait_B <- NA

N_taxa <- sum(tree_dat$isTip == T)
tree_dat$trait_A[1:N_taxa] <- rbinom(N_taxa, 1, 0.5)

tip_node_y <- tree_dat$y[tree_dat$isTip == T]
transition_point <- 20
tree_dat$trait_B[1:N_taxa] <- rbinom(N_taxa, 1,
                                     ifelse(tip_node_y > transition_point, 0.1, 0.9))

tree_dat$trait_A <- LETTERS[tree_dat$trait_A + 1]
tree_dat$trait_B <- LETTERS[tree_dat$trait_B + 1]
```

We now have two binary, discrete traits associated with the tips of the phylogeny. Trait_B is expected to show greater phylogenetic signal due to the non-random method by which it was created. Each trait can be plotted to see if this expectation looks likely:

```{r}
ggtree(tree) +
  geom_point(data = subset(tree_dat, isTip == TRUE),
             aes(col = trait_A, shape = trait_A), size = 2) +
  scale_color_manual(values = c('firebrick2', 'dodgerblue'))

ggtree(tree) +
  geom_point(data = subset(tree_dat, isTip == TRUE),
             aes(col = trait_B, shape = trait_B), size = 2) +
  scale_color_manual(values = c('maroon1', 'springgreen1'))
```

### Metrics quick look

Greater phylogenetic signal is expected to result in
- lower association index
- lower parsimony score
- higher UniFrac metric

```{r}
association_index(tree_dat, trait_var = 'trait_A')
association_index(tree_dat, trait_var = 'trait_B')

parsimony_score(tree_dat, trait_var = 'trait_A')
parsimony_score(tree_dat, trait_var = 'trait_B')

unifrac(tree_dat, trait_var = 'trait_A')
unifrac(tree_dat, trait_var = 'trait_B')
```

## Association Index

One metric to quantify phylogeny-trait correlation is the 'association index'  which depends on tree topology and the distribution of traits across tips. This can be calculated using the function `association_index()`. **Lower values of the association index indicate higher phylogeny-trait correlation**.

```{r}
association_index(tree_dat, trait_var = 'trait_A')
association_index(tree_dat, trait_var = 'trait_B')
```

The association index is calculated as the sum of a metric calculated for each internal node of the phylogeny. This per-node metric depends on i) the uniformity of traits distributed in tips descended from the node and ii) the number of tips descended. Per-node values can be returned from `association_index()` using `add_col = TRUE` and represented on the phylogeny using colour.

```{r}
AI <- association_index(tree_dat, trait_var = 'trait_B',
                              add_col = TRUE)
tree_dat <- AI[[2]]

ggtree(tree) +
  geom_point(aes(fill = tree_dat$association), shape = 21, size = 2) +
  geom_tippoint(aes(col = tree_dat$trait_B), size = 2) +
  scale_fill_gradientn(colours = brewer.pal(9, "YlOrRd")[2:8],
                        guide = "colourbar", name = "Node\nindex") +
  scale_color_manual(values = c('maroon1', 'springgreen1'), name = 'Trait B')

```


## Parsimony Score

With a discrete trait labelled in the tips. An alternative to the association index is the parsimony score which is the minimum number of trait changes required to result in the pattern of traits observed in the tips. **Lower parsimony scores indicate higher phylogeny-trait correlation**. There are some different methods of parsimonious reconstruction that vary in the proportion of internal nodes that are either resolved or left as ambiguous (i.e. NA).

To provide the lowest parsimony score possible, perform the first step of parsimonious reconstruction can be performed from tips to root solving nodes in unambiguous clades. Running the function `tips_2_root()` with the option `prefer_intersect == TRUE` provides one solution.

```{r}
# By default, tips_2_root() returns a list of option at internal nodes only
# To return a parsimony solution, use resolve_unambiguous == TRUE
tree_dat_temp <- tips_2_root(tree_dat, trait_var = 'trait_B',
                             prefer_intersect = TRUE,
                             resolve_unambiguous = TRUE,
                             inferred_column = 'trait_B')

ggtree(tree, aes(col = tree_dat_temp$trait_B)) +
  geom_point(data = tree_dat_temp,
             aes(col = trait_B, shape = trait_B), size = 2) +
  scale_color_manual(values = c('maroon1', 'springgreen1'), name = 'Trait B') +
  scale_shape_manual(values = c(16, 17), name = 'Trait B')
```

Running `tips_2_root()` with `prefer_intersect == TRUE` will generally result in a solution with a greater number of resolved nodes compared with `prefer_intersect == FALSE`.


```{r}
tree_dat_temp <- root_2_tips(tree_dat_temp, trait_var = 'trait_B')

ggtree(tree, aes(col = tree_dat_temp$trait_B)) +
  geom_point(data = tree_dat_temp,
             aes(col = trait_B, shape = trait_B), size = 2) +
  scale_color_manual(values = c('maroon1', 'springgreen1'), name = 'Trait B') +
  scale_shape_manual(values = c(16, 17), name = 'Trait B')
```

The above tree should now have trait inferred at each internal node and the number of trait transitions can be counted and is the parsimony score for the trait in question.

```{r}
tree_dat_temp <- does_trait_change(tree_dat_temp,  trait_var = 'trait_B')
cat('Parsimony score: ',
    sum(tree_dat_temp$trait_change == TRUE, na.rm = T))
```

The function `parsimony_score()` function packages up these last few steps, running `tips_2_root()` (with `prefer_intersect = TRUE`, by default), then `root_2_tips()`, before counting the number of trait changes using `does_trait_change()`. Compare trait A explored above with trait B which was designed to show greater phylogeny-trait correlation (*n.b.* **Lower parsimony scores indicate higher phylogeny-trait correlation**):

```{r}
# trait A
parsimony_score(tree_dat, trait_var = 'trait_A')

# trait B
ps <- parsimony_score(tree_dat, trait_var = 'trait_B', return_df = TRUE)

tree_dat_temp <- ps[[2]]

ggtree(tree, aes(col = tree_dat_temp$trait_B)) +
  geom_point(data = tree_dat_temp,
             aes(col = trait_B, shape = trait_B), size = 2) +
  scale_color_manual(values = c('maroon1', 'springgreen1'), name = 'Trait B') +
  scale_shape_manual(values = c(16, 17), name = 'Trait B')

```

## UniFrac

The UniFrac statistic measures the proportion, or fraction, of the phylogeny branch lengths that can be unambiguously assocaited with a particular trait value. It therefore depends on both tree topology and branch lengths, in contrast to the association index and parsimony scores. UniFrac therefore considers the genetic similarity among clustering taxa in addition to the extent to which taxa with the same trait values cluster together.

**Higher UniFrac scores indicate higher phylogeny-trait correlation**

```{r}
unifrac(tree_dat, trait_var = 'trait_A')
unifrac(tree_dat, trait_var = 'trait_B')
```

UniFrac requires the internal nodes of the phylogeny to be either unambiguously attributed to a trait value or determined to be ambiguous. This can be done using the function `tips_2_root()` with `prefer_intersect == FALSE`. In the resulting plot, ambiguous internal nodes/branches are labelled NA.

```{r}
tree_dat_temp <- tips_2_root(tree_dat, trait_var = 'trait_B',
                             prefer_intersect = FALSE,
                             resolve_unambiguous = TRUE,
                             inferred_column = 'trait_B')

ggtree(tree, aes(col = tree_dat_temp$trait_B)) +
  geom_point(data = tree_dat_temp,
             aes(col = trait_B, shape = trait_B), size = 2) +
  scale_color_manual(values = c('maroon1', 'springgreen1'), name = 'Trait B') +
  scale_shape_manual(values = c(16, 17), name = 'Trait B')

```

The function then sums the branch lengths that are coloured either pink or green on the above plot and divides this value by the total sum of branch lengths in the tree which also includes the lengths of the ambiguous branches shown in grey.

```{r}
uf <- unifrac(tree_dat, trait_var = 'trait_B', return_df = T)
tree_dat_temp <- uf[[2]]

len_A <- sum(tree_dat_temp$branch.length[which(tree_dat_temp$trait_B == 'A')])
len_A
len_B <- sum(tree_dat_temp$branch.length[which(tree_dat_temp$trait_B == 'B')])
len_B
len_ambig <- sum(tree_dat_temp$branch.length[is.na(tree_dat_temp$trait_B)])
len_ambig
len_all <- sum(tree_dat_temp$branch.length)

# check that partitioned branch lengths equal the total
len_A + len_B + len_ambig == len_all

# check manual calculation of UniFrac
(len_A + len_B) / len_all
unifrac(tree_dat, trait_var = 'trait_B')

```
